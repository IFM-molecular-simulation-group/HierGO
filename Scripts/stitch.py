#!/usr/bin/python3
import sys, os, random
import numpy as np
from argparse import ArgumentParser

## USAGE
# python3 stitch.py -files file1 file2 file3 file4
# python3 ../Scripts/stitch.py -files 0VAC-0O.pdb 0VAC-45O.pdb 5VAC-SMALL-30O.pdb 5VAC-SMALL-15O.pdb 10VAC-SMALL-30O.pdb 0VAC-30O.pdb 10VAC-SMALL-45O.pdb 20VAC-MEDIUM-60O.pdb 10VAC-SMALL-15O.pdb

## LIMITATIONS
#s - cell must be orthogonal
#  - must be square array of files
#  - files must have the same origin
#       | 
#       C   <-- Origin atom
#     /   \ 
#  - currently set up with no PBC

def rotate(origin, point, angle):
    """
    Rotate a point counterclockwise by a given angle around a given origin.

    The angle should be given in radians.
    """
    ox, oy = origin
    px, py = point

    qx = ox + np.cos(angle) * (px - ox) - np.sin(angle) * (py - oy)
    qy = oy + np.sin(angle) * (px - ox) + np.cos(angle) * (py - oy)
    return qx, qy

######################################################################
## Read pdb to local structure format
######################################################################
def read_pdb_to_structure(InputFile):
   Coords = np.array([])
   AtomTypes = []
   for line in open(InputFile):
       if "CRYST1" in line:
           PBC = line.split()
           ABC = np.array([ float(PBC[1]), float(PBC[2]), float(PBC[3]) ])
       elif "ATOM" in line or "HETATM" in line:
           fields = line.split()
           #coords.append( [ float(fields[5]), float(fields[6]), float(fields[7]) ] )
           if Coords.size == 0:
               Coords = np.append(Coords, [ float(fields[5]), float(fields[6]), float(fields[7]) ])
           else:
               Coords = np.vstack([Coords, [ float(fields[5]), float(fields[6]), float(fields[7]) ]])
           AtomTypes.append( fields[2] )

   return(Coords,AtomTypes,ABC)

######################################################################
## Write an output PDB file
######################################################################
def write_pdb_file(coords,atomtypes,abc,FileName):
    newlines = []
    count = 0
    for i in range(0,len(coords)):
        #newlines.append(i)
        #newlines.append(coords[i])
        #print("{:6s}{:5d} {:^4s} {:3s}  {:4d}    {:8.3f}{:8.3f}{:8.3f}{:6.2f}{:6.2f}          {:>2s}".format("ATOM",count,str(atomtypes[i]),"UNL",1,coords[i][0],coords[i][1],coords[i][2]+31.675,1.00,0.00,str(atomtypes[i])))
        #newlines.append("{:6s}{:5d} {:^4s} {:3s}  {:4d}    {:8.3f}{:8.3f}{:8.3f}{:6.2f}{:6.2f}          {:>2s}".format("ATOM",count,str(atomtypes[i]),"UNL",1,coords[i][0],coords[i][1],coords[i][2],1.00,0.00,str(atomtypes[i])))
        newlines.append("{:6s}{:5d} {:^4s} {:3s}  {:4d}    {:8.3f}{:8.3f}{:8.3f}{:6.2f}{:6.2f}          {:>2s}".format("ATOM",count,str(atomtypes[i]),"UNL",1,coords[i][0],coords[i][1],coords[i][2],1.00,0.00,str(atomtypes[i])))
        count += 1

    print("Writing output file %s"%(FileName))

    file = open(FileName,"w")
    file.write("AUTHOR    GENERATED BY NG TILE DECORATION\n")
    file.write("CRYST1 {:8.3f} {:8.3f} {:8.3f} {:6.2f} {:6.2f} {:6.2f} P1          1\n".format(abc[0],abc[1],abc[2],90.0,90.0,90.0))
    for line in newlines:
        file.write("%s\n"%(line))
    file.close()

    return()

######################################################################
## Return an absolute pathway from a relative one
######################################################################
def get_absolute_path(RelativePath):
    path = os.getcwd()
    PathFields = path.split("/")
    InputTileFields = RelativePath.split("/")
    for i in InputTileFields:
        if i == "..":
            PathFields = PathFields[:-1]
        else:
            PathFields.append(i)
    newpath = ""
    for i in PathFields:
        if i[-3:] == "cif":
            newpath = newpath+i
        else:
            newpath = newpath+i+"/"
    return(newpath)

######################################################################
## Decide top or bottom randomly
######################################################################
def coin_flip():
    Side = random.choice([True,False])
    if Side == True:
        return(True)
    return(False)

######################################################################
######################################################################


######################################################################
## Read inputs
######################################################################
def read_inputs():
    parser = ArgumentParser(description='A code to stitch tiles together. \
    Visually inspect geometry afterwards to ensure an intuitive geometry.')
    parser.add_argument('--infiles', nargs='+', help='<Required> Set flag; input file name (pdb)', required=True)
    parser.add_argument('--percento', help='overall amount of oxygen, \
    oxygen will be added to the edges in order to satisfy this percent, \
    defaults to 0', default=0, type=float)
    parser.add_argument('--add_oxygen_to_sheet_edges', help='add oxygen \
    determined from the --percento flag to the sheet edges only. Defaults \
    to False', action='store_true')
    parser.add_argument('--array', nargs=2, help='number of rows and \
    columns of tiles; if not set code will attempt to create a square \
    array')
    parser.add_argument('--keep_overlap', action='store_true', help='optional \
    flag to keep overlapping oxygen and carbon, which by default are trimmed')
    parser.add_argument('--keep_hanging_carbon', action='store_true', help='optional \
    flag to keep hanging carbon atoms, which by default are trimmed')
    parser.add_argument('--ordered_tiles', action='store_true', help='optional \
    flag to keep the input order of the tiles, which by default are randomized')
    parser.add_argument('--pbc', action='store_true', help='optional \
    flag to keep periodic boundary conditions, otherwise buffer distance of 10Ang is added')
    parser.add_argument('--outfile', nargs='?', default="stitched.pdb", type=str, help="output file name (pdb)")

    args = parser.parse_args()
    tiles = None
    if args.array != None:
        tiles = []
        for i in args.array:
            tiles.append(int(i))
    return(args.infiles,args.percento,tiles,args.outfile,args.keep_overlap,args.keep_hanging_carbon,args.ordered_tiles,args.pbc,args.add_oxygen_to_sheet_edges)

######################################################################
## Check that array is square
######################################################################
def check_square_array(numTiles):
    row = (numTiles)**(0.5)
    if row.is_integer():
        return(int(row))
    else:
        sys.exit("Wrong number of tile files provided, must be able to create square array.")

######################################################################
## 
######################################################################
def randomize_list(TileList):
    print(TileList)
    print("Random tile order: ")
    NewTileList = []
    for i in range(0,len(TileList)):
        a = random.choice(TileList)
        NewTileList.append(a)
        TileList.remove(a)
        print(a,end=" ")
    print("")
    print(NewTileList)
    return(NewTileList)

######################################################################
## Determine array based on PBC
######################################################################
def determine_array(Array,PBC):
    TranslateList = []
    for a in range(0,Array[0]):
        for b in range(0,Array[1]):
            TranslateList.append([a*PBC[0],b*PBC[1]])
    return(TranslateList)

######################################################################
## Determine new lattice parameters from factor and previous PBC
######################################################################
def determine_new_lattice(Array,PBCL):
    NewPBC = np.array([ PBCL[0]*Array[0], PBCL[1]*Array[1], PBCL[2] ])
    return(NewPBC)

######################################################################
## stitch tiles together
######################################################################
def stitch_tiles(TileList,Array):
    print("Reading tile 0")
    FirstTileCoords,FirstTileAtomtypes,PBC = read_pdb_to_structure(TileList[0])
    TranslateList = determine_array(Array,PBC)
    ## New PBC in "Lattice" format
    NewPBC = determine_new_lattice(Array,PBC)
    allcoordinates = np.array([])
    allspecies = []
    TileEdges = [[0.0,0.0,0.0]]
    for i in range(0,len(FirstTileCoords)):
        if allcoordinates.size == 0:
            allcoordinates = np.append(allcoordinates,[FirstTileCoords[i]])
        else:
            allcoordinates = np.vstack([allcoordinates,FirstTileCoords[i]])
        allspecies.append(FirstTileAtomtypes[i])
    for i in range(1,Array[0]*Array[1]):
        print("Reading tile %s"%(i))
        #print(TileList)
        Coords,Atomtypes,PBC = read_pdb_to_structure(TileList[i])
        TranslateVector = [ TranslateList[i][0], TranslateList[i][1], 0]
        TileEdges.append(TranslateVector)
        print("    Translating by %s"%(TranslateVector))
        for b in range(0,len(Coords)):
            allcoordinates = np.vstack([allcoordinates,[Coords[b][0] + TranslateList[i][0], Coords[b][1] + TranslateList[i][1], Coords[b][2] ]])
            allspecies.append(Atomtypes[b])
    ## the last tile edge
    TileEdges.append([PBC[0],0.0,0.0])
    TileEdges.append([0.0,PBC[1],0.0])
    return(allcoordinates,allspecies,NewPBC,TileEdges)

######################################################################
## FV NN
######################################################################
def distance(x0, x1, box, pbc):
    # xo is a position of one atom, x1 is an array of positions
    # use the pbc bool mask to set the periodicity
    delta = np.abs(x0 - x1)
    delta[:,pbc] -= box[pbc] * np.round(delta[:,pbc]/(box[pbc]))
    return(np.sqrt((delta ** 2).sum(axis=-1)))

def nearest_neighbors_fv(Coords, box, Cutoff):
    pbc = np.full(3, True)
    NNList = []
    for i in range(0,len(Coords)):
        NNList.append([])
    for i,pos in enumerate(Coords):
        dists = distance(pos, Coords, box, pbc)
        mask = (dists > 1e-15) & (dists <= Cutoff)
        for j in mask.nonzero()[0]:
            NNList[i].append(j)
    return(NNList)

######################################################################
## TODO rewrite to use NNList and modify cutoff per atomtype
######################################################################
#def nearest_neighbors(coords,abc,cutoff):
def nearest_neighbors_typed(coords,AtomTypes,abc,NNList):
    CCutoff = 1.75
    CHCutoff = 1.6
    NewNNList = []
    for i in range(0,len(coords)):
        ix = coords[i][0]
        iy = coords[i][1]
        iz = coords[i][2]
        NeighborElements = []
        for j in NNList[i]:
            jx = coords[j][0]
            jy = coords[j][1]
            jz = coords[j][2]
            dx = abs(ix - jx)
            if dx >= (abc[0]*0.5):
                dx -= abc[0]
            dy = abs(iy - jy)
            if dy >= (abc[1]*0.5):
                dy -= abc[1]
            dz = abs(iz - jz)
            if dz >= (abc[2]*0.5):
                dz -= abc[2]
            d = (dx**2 + dy**2 + dz**2 )**0.5
            if "H" in AtomTypes[i] or "H" in AtomTypes[j]:
                cutoff = CHCutoff
            else:
                cutoff = CCutoff
            if d <= cutoff and i != j:
                NeighborElements.append(j)
        NewNNList.append(NeighborElements)
    return(NewNNList)

######################################################################
## Check if the index atom i is overlapping with other atoms given a 
## NNList which only includes overlap
######################################################################
def is_atom_overlapping(i,AtomTypes,NNList,AtomsToRemove):
    ## remove hydrogens which overlap with anything
    if "H" in AtomTypes[i]:
        if len(NNList[i]) > 0:
            return(True)
    ## remove oxygens which overlap with carbon or oxygen which has 
    ## not yet been flagged
    elif "O" in AtomTypes[i]:
        if len(NNList[i]) > 0:
            for n in NNList[i]:
                if n not in AtomsToRemove:
                    if "C" in AtomTypes[n]:
                        return(True)
                    elif "O" in AtomTypes[n]:
                        return(True)
    ## remove carbons which overlap with other carbons which have 
    ## not yet been flagged
    elif "C" in AtomTypes[i]:
        if len(NNList[i]) > 0:
            for n in NNList[i]:
                if n not in AtomsToRemove:
                    if "C" in AtomTypes[n]:
                        return(True)
    return(False)

######################################################################
## Remove 0.5 Ang overlapping atoms
######################################################################
def remove_overlapping_atoms(AtomTypes, PBC, Coords):
    ## 0.5 Ang bond distance is too close
    NNList = nearest_neighbors_fv(Coords, PBC, 0.5)
    AtomsToRemove = []
    for i in range(0,len(AtomTypes)):
        if is_atom_overlapping(i,AtomTypes,NNList,AtomsToRemove):
            AtomsToRemove.append(i)

    NewCoords = np.array([])
    NewAtomTypes = []
    for i in range(0,len(AtomTypes)):
        if i in AtomsToRemove:
            pass
        else:
            if NewCoords.size == 0:
                NewCoords = np.append(NewCoords,[Coords[i]])
            else:
                NewCoords = np.vstack([NewCoords,Coords[i]])
            NewAtomTypes.append(AtomTypes[i])
    return(NewCoords, NewAtomTypes)

######################################################################
## Check if the oxygen atom i is overlapping with other oxygen 
## atoms given a NNList which only includes overlap
######################################################################
def is_oxygen_bordering(i,AtomTypes,NNList,AtomsToRemove):
    if len(NNList[i]) > 0:
        for n in NNList[i]:
            if n not in AtomsToRemove:
                if "O" in AtomTypes[n]:
                    return(True)
    return(False)

######################################################################
## Check if the oxygen atom i is bonded to a carbon which is bonded 
## to an epoxy oxygen
######################################################################
def is_oxygen_neighboring_epoxy(i,AtomTypes,NNList,AtomsToRemove):
    ## for oxygen neighbors
    for n in NNList[i]:
        if "C" in AtomTypes[n]:
            for nn in NNList[n]: 
                if nn != i:
                    if "O" in AtomTypes[nn]:
                        if len(NNList[nn]) == 2:
                            if ("C" in AtomTypes[NNList[nn][0]]) and ("C" in AtomTypes[NNList[nn][1]]):
                                return(True)
    return(False)

######################################################################
## Find oxygen groups which border one another and remove one of them
## also remove groups bonded to the same carbon as an epoxy/ether
######################################################################
def remove_bordering_oxygen(AtomTypes, PBC, Coords):
    ## 1.5 Ang bond distance is too close for O-O
    NNList = nearest_neighbors_fv(Coords, PBC, 1.5)
    AtomsToRemove = []
    for i in range(0,len(AtomTypes)):
        if "O" in AtomTypes[i]:
            if is_oxygen_bordering(i,AtomTypes,NNList,AtomsToRemove):
                AtomsToRemove.append(i)
                for n in NNList[i]:
                    if "H" in AtomTypes[n]:
                        AtomsToRemove.append(n)
            elif is_oxygen_neighboring_epoxy(i,AtomTypes,NNList,AtomsToRemove):
                print(Coords[i])
                AtomsToRemove.append(i)
                for n in NNList[i]:
                    if "H" in AtomTypes[n]:
                        AtomsToRemove.append(n)

    NewCoords = []
    NewAtomTypes = []
    for i in range(0,len(AtomTypes)):
        if i in AtomsToRemove:
            pass
        else:
            NewCoords.append(Coords[i])
            NewAtomTypes.append(AtomTypes[i])
    return(NewCoords, NewAtomTypes)

######################################################################
## Return true if a carbon is within a six-membered ring, false if not
######################################################################
def carbon_ring(i,NNList,atomtypes):
    for nn in NNList[i]:
        if "C" in atomtypes[nn]:
            for nnn in NNList[nn]:
                if "C" in atomtypes[nnn]:
                    if nnn != i:
                        for nnnn in NNList[nnn]:
                            if "C" in atomtypes[nnnn]:
                                if nnnn != nn:
                                    for nnnnn in NNList[nnnn]:
                                        if "C" in atomtypes[nnnnn]:
                                            if nnnnn != nnn:
                                                for nnnnnn in NNList[nnnnn]:
                                                    if "C" in atomtypes[nnnnnn]:
                                                        if nnnnnn != nnnn:
                                                            for nnnnnnn in NNList[nnnnnn]:
                                                                if nnnnnnn == i:
                                                                    return(True)
    return(False)

######################################################################
## Return true if a carbon is within a five, six, or 
## seven-membered ring, false if not
######################################################################
def carbon_567_ring(i,NNList,atomtypes):
    for nn in NNList[i]:
        if "C" in atomtypes[nn]:
            for nnn in NNList[nn]:
                if "C" in atomtypes[nnn]:
                    if nnn != i:
                        for nnnn in NNList[nnn]:
                            if "C" in atomtypes[nnnn]:
                                if nnnn != nn:
                                    for nnnnn in NNList[nnnn]:
                                        if "C" in atomtypes[nnnnn]:
                                            if nnnnn != nnn:
                                                for nnnnnn in NNList[nnnnn]:
                                                    if "C" in atomtypes[nnnnnn]:
                                                        if nnnnnn == i: ## 5-mem ring
                                                            #print("5 %s"%(i))
                                                            return(True)
                                                        elif nnnnnn != nnnn:
                                                            for nnnnnnn in NNList[nnnnnn]:
                                                                if "C" in atomtypes[nnnnnnn]:
                                                                    if nnnnnnn == i: ## 6-mem ring
                                                                        return(True)
                                                                    elif nnnnnnn != nnnnn:
                                                                        for nnnnnnnn in NNList[nnnnnnn]:
                                                                            if nnnnnnnn == i: ## 7-mem ring
                                                                                return(True)
                                                                            elif nnnnnnnn != nnnnnn:
                                                                                for nnnnnnnnn in NNList[nnnnnnn]:
                                                                                    if nnnnnnnnn == i: ## 8-mem ring
                                                                                        return(True)
    return(False)

######################################################################
## 
######################################################################
def find_rings(coords, atomtypes, NNList):
    Rings = []
    for i in range(0,len(atomtypes)):
        if "C" in atomtypes[i]:
            RingElement = carbon_567_ring(i,NNList,atomtypes)
            Rings.append(RingElement)
        else:
            Rings.append([])
    return(Rings)

def on_boundary(i,TileEdges):
    for edge in TileEdges:
        dx = abs(edge[0] - i[0])
        dy = abs(edge[1] - i[1])
        if dx < 2.0 or dy < 2.0:
            return(True)
    return(False)

######################################################################
## 
## TODO: does not capture edge carbons bonded to one carbon and one oxygen
######################################################################
def trim_hanging_carbons(atomtypes, PBC, coords, TileEdges):
    MinDist = 1.75 #C-C bond distance
    newcoords = []
    newatomtypes = []
    numatoms = 0
    moreHangingCarbons = False
    NNList = nearest_neighbors_fv(coords, PBC, MinDist)
    Rings = find_rings(coords, atomtypes, NNList)
    #NNNList = nearest_neighbors_FV(coords, PBC, 2.9)
    for i in range(0,len(atomtypes)):
        if len(NNList[i]) == 0:
            pass
        ## check that carbons are a part of a ring only on the tile boundaries
        #elif on_boundary(coords[i],TileEdges) and Rings[i] == False:
        elif Rings[i] == False:
            print(i,end=" ")
            moreHangingCarbons = True
        #elif ("C" in atomtypes[i] or "O" in atomtypes[i]) and (len(NNList[i]) < 2):
        elif ("C" in atomtypes[i]) and (len(NNList[i]) < 2):
            moreHangingCarbons = True
            pass
        elif ("O" in atomtypes[i]) and (len(NNList[i]) == 1) and ("C" not in atomtypes[NNList[i][0]]):
            moreHangingCarbons = True
            pass
        #elif ("O" in atomtypes[i]) and (len(NNList[i]) == 2) and ("C" not in atomtypes[NNList[i][0]] or "C" not in atomtypes[NNList[i][1]]):
        #    moreHangingCarbons = True
        #    pass
        elif ("C" in atomtypes[i]) and (len(NNList[i]) == 2) and ("C" not in atomtypes[NNList[i][0]] or "C" not in atomtypes[NNList[i][1]]):
            moreHangingCarbons = True
            pass
        elif ("H" in atomtypes[i]) and (len(NNList[i]) == 1) and ("H" in atomtypes[NNList[i][0]]):
            moreHangingCarbons = True
            pass
        elif ("H" in atomtypes[i]) and (len(NNList[i]) == 2) and ("H" in atomtypes[NNList[i][0]] and "H" in atomtypes[NNList[i][1]]):
            moreHangingCarbons = True
            pass
        #elif ("C" in atomtypes[i] or "O" in atomtypes[i]) and len(NNList[i]) == 2 and ((len(NNNList[(NNList[i][0])]) <= 6) or (len(NNNList[(NNNList[i][1])]) <= 6)):
            #moreHangingCarbons = True
            #pass
        else:
            newcoords.append( coords[i] )
            newatomtypes.append(atomtypes[i])
            numatoms += 1
    return(numatoms, newcoords, newatomtypes, moreHangingCarbons)

######################################################################
## Average the two carbon positions, flip it across the original carbon 
## and scale the bond to 1.0
######################################################################
def calculate_hydrogen_coordinates(c1,c2,c3):
    # move to origin
    ba = np.array(c2) - np.array(c1)
    bc = np.array(c3) - np.array(c1)
    d1 = (ba[0]**2 + ba[1]**2)**0.5
    d2 = (bc[0]**2 + bc[1]**2)**0.5
    ## With SW defects the carbons are not symmetric which causes problems for the 
    ## hydrogen flipping
    if abs(d1 - d2) > 0.1:
        if d1 < d2:
            new = np.average(np.array([ ba, bc ]), axis=0, weights=np.array([2,1]))
        else:
            new = np.average(np.array([ ba, bc ]), axis=0, weights=np.array([1,2]))
    ## Symmetric case is averaged
    else:
        new = np.mean( np.array([ ba, bc ]), axis=0 )
    new = new*np.array([-1,-1])
    if new[0] == 0.0:
        theta = np.pi*0.5
    else:
        theta = abs(np.arctan((new[1]/new[0])))
    new_scaled = np.array([ np.cos(theta), np.sin(theta) ]) #for bond length of 1
    if new[0] < 0:
        new_scaled[0] = new_scaled[0]*-1
    if new[1] < 0:
        new_scaled[1] = new_scaled[1]*-1
    new_scaled += np.array(c1)

    return(new_scaled[0],new_scaled[1])

######################################################################
## Add hydrogens to non-decorated edge carbons
######################################################################
#def add_hydrogen(Coords,ABC,EdgeSites,NNList,NewH):
def add_hydrogen(Coords,atomtypes,ABC,NewH):
    NNList = nearest_neighbors_fv(Coords,ABC,1.75)
    NNList = nearest_neighbors_typed(Coords,atomtypes,ABC,NNList)
    upAtoms = []
    downAtoms = []
    for Atom in range(0,len(Coords)):
        Neighbors = NNList[Atom]
        CNeighbors = []
        for Neighbor in Neighbors:
            if "C" in atomtypes[Neighbor]:
                CNeighbors.append(Neighbor)
        ## carb acid c atoms and/or spurious hanging carbons
        if len(CNeighbors) < 2 and "C" in atomtypes[Atom]:
            #print("< 2 for %s"%(Atom))
            pass
        elif len(Neighbors) < 3 and "C" in atomtypes[Atom]:
            c1x,c1y,c1z = Coords[Atom]
            c2 = [ Coords[CNeighbors[0]][0],Coords[CNeighbors[0]][1] ]
            c3 = [ Coords[CNeighbors[1]][0],Coords[CNeighbors[1]][1] ]
            ## Make sure vectors do not cross boundary
            c2,c3 = remove_PBC([c1x,c1y],c2,c3,ABC)
            ## Calculate hydrogen coordinates
            hx,hy = calculate_hydrogen_coordinates([c1x,c1y],c2,c3)
            hCoords = [ hx,hy,Coords[Atom][2] ]
            ## Append coordinates
            NewH.append(hCoords)
    return(NewH)


######################################################################
## Add new atoms
######################################################################
def add_new_atoms(coords,oldatomtypes,NewC,NewO,NewH):
    newcoords = coords
    atomtypes = []
    for oldatom in range(0,len(coords)):
    #    print("C %s %s %s"%(cCoords[0],cCoords[1],cCoords[2]))
         #newcoords.append(coords[oldatom])
         atomtypes.append(oldatomtypes[oldatom])
    for cCoords in NewC:
    #    print("O %s %s %s"%(oCoords[0],oCoords[1],oCoords[2]))
         newcoords = np.vstack([newcoords, cCoords])
         atomtypes.append("C")
    for oCoords in NewO:
    #    print("O %s %s %s"%(oCoords[0],oCoords[1],oCoords[2]))
         newcoords = np.vstack([newcoords, oCoords])
         atomtypes.append("O")
    for hCoords in NewH:
    #    print("H %s %s %s"%(hCoords[0],hCoords[1],hCoords[2]))
         newcoords = np.vstack([newcoords, hCoords])
         atomtypes.append("H")
    return(newcoords,atomtypes)

######################################################################
## Add hydrogen to two-fold coordinated carbon
######################################################################
def add_only_hydrogen(coords,atomtypes,abc):
    NewH = add_hydrogen(coords,atomtypes,abc,[])
    coords,atomtypes = add_new_atoms(coords,atomtypes,[],[],NewH)
    #newcoords = wrap_coords(coords,abc)
    return(coords,atomtypes)

######################################################################
## Apply rotation for bond
######################################################################
def rotate_atom(x,y,z):
    angle = np.pi/3
    possibleRotations = [0,angle,angle*2,angle*3,angle*4,angle*5]
    RandomRotation = random.choice(possibleRotations)
    x,y = rotate( (0,0), (x,y), RandomRotation)
    return(x,y,z)

def remove_PBC(c1,c2,c3,abc):
    #print(c1,c2,c3)
    ## Center c2 and c3 about c1
    d3 = [ c3[0] - c1[0], c3[1] - c1[1] ]
    if d3[0] >= (abc[0]*0.5):
        c3[0] -= abc[0]
    elif d3[0] <= -(abc[0]*0.5):
        c3[0] += abc[0]
    if d3[1] >= (abc[1]*0.5):
        c3[1] -= abc[1]
    elif d3[1] <= -(abc[1]*0.5):
        c3[1] += abc[1]
    d2 = [ c2[0] - c1[0], c2[1] - c1[1] ]
    if d2[0] >= (abc[0]*0.5):
        c2[0] -= abc[0]
    elif d2[0] <= -(abc[0]*0.5):
        c2[0] += abc[0]
    if d2[1] >= (abc[1]*0.5):
        c2[1] -= abc[1]
    elif d2[1] <= -(abc[1]*0.5):
        c2[1] += abc[1]
    #print(c1,c2,c3)
    return(c2,c3)

######################################################################
## Add hydroxyl oxygen and hydrogen      c---o
## c = [ x1, y1, z1]                          \
##                                             h
## Assumes neighboring carbons are in xy plane
## OH bond is a bit funny to break any possible overlap
## C-O bond is LONG to prevent overlap - vmd likes to draw C-O bonds 
## apparently and for topology generation this is a problem
######################################################################
def add_hydroxyl(c,up):
    ox,oy,oz = c[0],c[1],c[2]
    if up == True:
        #oz += 1.32
        oz += 1.6
        #hx,hy,hz = rotate_atom(0.885,0.0,0.314)
        hx,hy,hz = rotate_atom(0.4,0.0,0.8)
    else:
        #oz -= 1.32
        oz -= 1.6
        #hx,hy,hz = rotate_atom(0.885,0.0,-0.314)
        hx,hy,hz = rotate_atom(0.4,0.0,-0.8)
    oCoords = [ox,oy,oz]
    hCoords = [ox+hx,oy+hy,oz+hz]
    return(oCoords,hCoords)

######################################################################
## Basically the same as the hydrogen placement function
######################################################################
def add_carboxylicacid_carbon(c1,c2,c3):
    # move to origin
    ba = np.array(c2) - np.array(c1)
    bc = np.array(c3) - np.array(c1)
    new = np.mean( np.array([ ba, bc ]), axis=0 )
    new = new*np.array([-1,-1])
    theta = abs(np.arctan((new[1]/new[0])))
    new_scaled = np.array([ np.cos(theta)*1.3, np.sin(theta)*1.3 ]) #for bond length of 1.3
    if new[0] < 0:
        new_scaled[0] = new_scaled[0]*-1
    if new[1] < 0:
        new_scaled[1] = new_scaled[1]*-1
    new_scaled += np.array(c1)
    return(new_scaled[0],new_scaled[1])

######################################################################
## Calculate coordinates for carbon of carb acid group
######################################################################
def choose_carbacid_atoms(c1index,coords,ABC,NNList):
    c1x,c1y,c1z = coords[c1index]
    c2 = [ coords[NNList[c1index][0]][0], coords[NNList[c1index][0]][1] ]
    c3 = [ coords[NNList[c1index][1]][0], coords[NNList[c1index][1]][1] ]
    c2,c3 = remove_PBC([c1x,c1y],c2,c3,ABC)
    c4x,c4y = add_carboxylicacid_carbon([c1x,c1y],c2,c3 )
    c4Coords = [c4x,c4y,c1z]
    return(c4Coords)

######################################################################
## Add carbonyl oxygen        |    
## c = [ x1, y1, z1]          c=o
##                            |
######################################################################
def add_carbonyl(c,up):
    ox,oy,oz = c[0],c[1],c[2]
    if up == True:
        oz += 1.5
    else:
        oz -= 1.5
    oCoords = [ox,oy,oz]
    return(oCoords)

######################################################################
## Ensure that there are the same # of oxygens on either side
######################################################################
def choose_direction(o_up,o_down,o_tot):
    if o_up <= (o_tot*0.5) and o_down <= (o_tot*0.5):
        up = coin_flip()
    elif o_up >= (o_tot*0.5) and o_down <= (o_tot*0.5):
        up = False
    elif o_up >= (o_tot*0.5) and o_down <= (o_tot*0.5):
        up = True
    else: #Handle odd numbers
        up = coin_flip()
    if up == False:
        o_down += 1
    else:
        o_up += 1
    return(o_up,o_down,up)

def check_oxygen_overlap(oCoords,NewO,abc):
    for oxygen in NewO:
        dx = abs(oCoords[0] - oxygen[0])
        if dx >= (abc[0]*0.5):
            dx -= abc[0]
        dy = abs(oCoords[1] - oxygen[1])
        if dy >= (abc[0]*0.5):
            dy -= abc[0]
        dz = abs(oCoords[2] - oxygen[2])
        if dz >= (abc[0]*0.5):
            dz -= abc[0]
        d = ( dx**2 + dy**2 + dz**2)**0.5
        if d < 1.9:
            return(True)
    return(False)

def determine_sheet_edges(TileEdges):
#[[0.0, 0.0, 0.0], [0.0, 51.338, 0], [49.42, 0.0, 0], [49.42, 51.338, 0], [49.42, 0.0, 0.0], [0.0, 51.338, 0.0]]
    SheetEdges = [TileEdges[0],[0,TileEdges[1][1]+TileEdges[3][1],0],[TileEdges[2][0]+TileEdges[3][0],0,0]]
    print(SheetEdges)
    return(SheetEdges)

######################################################################
## Add carbonyl/carboxylic acid oxygen groups and hydrogen to two-fold 
## coordinated carbon atoms
######################################################################
def add_oxygen_hydrogen(coords,atomtypes,abc,PercentO,AddOxygenToSheetEdges,TileEdges):
    if AddOxygenToSheetEdges:
        SheetEdges = determine_sheet_edges(TileEdges)

    NNList = nearest_neighbors_fv(coords,abc,1.85)
    NNList = nearest_neighbors_typed(coords,atomtypes,abc,NNList)
    o_up = 0
    o_down = 0
    NewO = []
    NewH = []
    NewC = []

    ## Calculate number of oxygen to add based on current number
    NumO = 0
    NumC = 0
    for Atom in atomtypes:
        if "O" in Atom:
            NumO += 1
        elif "C" in Atom:
            NumC += 1
    NumOxygen = int(((PercentO/100 - (NumO/NumC))*NumC)*0.33)
    print("Desired oxygen percent is %s"%(PercentO))
    print("Current oxygen percent is %s"%(NumO/NumC*100))
    print("Adding %s oxygen atoms"%(NumOxygen/0.33))

    ## Find two-fold carbon sites
    TwoFoldCarbonList = []
    for Atom in range(0,len(coords)):
        Neighbors = NNList[Atom]
        CNeighbors = []
        for Neighbor in Neighbors:
            if "C" in atomtypes[Neighbor]:
                CNeighbors.append(Neighbor)
        if len(CNeighbors) < 2 and "C" in atomtypes[Atom]:
            print("< 2 for %s"%(Atom)) ## carb acid sites
        elif len(Neighbors) < 3 and "C" in atomtypes[Atom]:
            if AddOxygenToSheetEdges:
                if on_boundary(coords[Atom],SheetEdges):
                    TwoFoldCarbonList.append(Atom)
            else:
                TwoFoldCarbonList.append(Atom)

    ## Add carbonyl
    for i in range(0,NumOxygen):
        c1 = random.choice(TwoFoldCarbonList)
        TwoFoldCarbonList.remove(c1)
        #o_up,o_down,up = choose_direction(o_up,o_down,NumOxygen)
        ## use carb acid carbon function instead to prevent overlap
        oCoords = choose_carbacid_atoms(c1,coords,abc,NNList)
        #oCoords = add_carbonyl(coords[c1],up)
        NewO.append(oCoords)

    ## Carb acid
    for i in range(0,NumOxygen):
        c1 = random.choice(TwoFoldCarbonList)
        c4Coords = choose_carbacid_atoms(c1,coords,abc,NNList)
        TwoFoldCarbonList.remove(c1)
        while check_oxygen_overlap(c4Coords,NewO,abc) == True:
            c1 = random.choice(TwoFoldCarbonList)
            c4Coords = choose_carbacid_atoms(c1,coords,abc,NNList)
            TwoFoldCarbonList.remove(c1)
        NewC.append(c4Coords)
        if coin_flip() == True:
            o1Coords = add_carbonyl(c4Coords,True)
            o2Coords,h2Coords = add_hydroxyl(c4Coords,False)
        else:
            o1Coords = add_carbonyl(c4Coords,False)
            o2Coords,h2Coords = add_hydroxyl(c4Coords,True)
        NewO.append(o1Coords)
        NewO.append(o2Coords)
        NewH.append(h2Coords)

    ## Add hydrogen to remaining two fold coordinated carbons
    for Atom in TwoFoldCarbonList:
        Neighbors = NNList[Atom]
        CNeighbors = []
        for Neighbor in Neighbors:
            if "C" in atomtypes[Neighbor]:
                CNeighbors.append(Neighbor)
        c1x,c1y,c1z = coords[Atom]
        c2 = [ coords[CNeighbors[0]][0],coords[CNeighbors[0]][1] ]
        c3 = [ coords[CNeighbors[1]][0],coords[CNeighbors[1]][1] ]
        ## Make sure vectors do not cross boundary
        #c2,c3 = remove_PBC([c1x,c1y],c2,c3,ABC)
        ## Calculate hydrogen coordinates
        hx,hy = calculate_hydrogen_coordinates([c1x,c1y],c2,c3)
        hCoords = [ hx,hy,coords[Atom][2] ]
        ## Append coordinates
        NewH.append(hCoords)

    coords,atomtypes = add_new_atoms(coords,atomtypes,NewC,NewO,NewH)
    return(coords,atomtypes)

######################################################################
## MAIN
######################################################################
def main():
    ## Read inputs
    TileList,PercentO,Array,OutputFile,KeepOverlap,KeepHangingCarbon,OrderedTiles,Periodic,AddOxygenToSheetEdges = read_inputs()
    ## Check square array
    if Array == None:
        row = check_square_array(len(TileList))
        Array = [row,row]
    ## Random order
    if OrderedTiles == False:
        TileList = randomize_list(TileList)
    ## stitch Tiles
    Coords,AtomTypes,PBC,TileEdges = stitch_tiles(TileList,Array)
    if Periodic != True:
        PBC += [10,10,0]
    write_pdb_file(Coords,AtomTypes,PBC,"stitched-log.pdb")
    ## Record original number of carbons for output purposes
    OriginalNumCarbons = len(Coords)
    ## Remove overlapping atoms
    #if KeepOverlap != True:
    #    Coords, AtomTypes = remove_overlapping_atoms(AtomTypes, PBC, Coords)
    #    Coords, AtomTypes = remove_bordering_oxygen(AtomTypes, PBC, Coords)
    #    write_pdb_file(Coords,AtomTypes,PBC,"stitched-log-1.pdb")
    ## Remove new hanging carbons 
    if KeepHangingCarbon != True:
        Atoms, Coords, AtomTypes, MoreHangingCarbons = trim_hanging_carbons(AtomTypes, PBC, Coords, TileEdges)
        write_pdb_file(Coords,AtomTypes,PBC,"stitched-trim-0.pdb")
        cycle = 0
        while MoreHangingCarbons == True:
            print("Trimming Cycle: %s"%(cycle))
            Atoms, Coords, AtomTypes, MoreHangingCarbons = trim_hanging_carbons(AtomTypes, PBC, Coords, TileEdges)
            cycle += 1
            write_pdb_file(Coords,AtomTypes,PBC,"stitched-trim-%s.pdb"%(cycle))
    ## Add hydrogens 
    #Coords,AtomTypes,PBC = read_pdb_to_structure("ortho-n.pdb")
    print("Adding hydrogen to new dangling carbons")
    if PercentO == 0:
        Coords,AtomTypes = add_only_hydrogen(Coords,AtomTypes,PBC)
    else:
        Coords,AtomTypes = add_oxygen_hydrogen(Coords,AtomTypes,PBC,PercentO,AddOxygenToSheetEdges,TileEdges)
        if AddOxygenToSheetEdges:
            Coords,AtomTypes = add_only_hydrogen(Coords,AtomTypes,PBC)
    ## Write final coords
    write_pdb_file(Coords,AtomTypes,PBC,OutputFile)
    print("Removed %s atoms"%(OriginalNumCarbons-len(Coords)))

main()
